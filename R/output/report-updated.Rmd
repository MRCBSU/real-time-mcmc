---
title: 'COVID-19: nowcast and forecast'
author: "Paul Birrell, Joshua Blake, Edwin van Leeuwen, Daniela De Angelis, Joint PHE Modelling Cell, and MRC Biostatistics Unit COVID-19 Working Group."
date: "`r lubridate::today()`"
output:
  html_document:
    self_contained: no
---

```{r preamble, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
QUANTILES <- c(0.025, 0.5, 0.975)

suppressMessages(library(knitr))
suppressMessages(library(DT))
suppressMessages(library(lubridate))
suppressMessages(library(plotly))
suppressMessages(library(tidyverse))
if(exists("Rfile.loc")) {
  source(file.path(Rfile.loc, "results_api.R"))
} else {
  proj.dir <- "~/RTM"
  source("results_api.R")
}

```

```{r combine-Rt}
inf_by_region <- apply(infections, c("iteration", "date", "region"), sum)[seq(from = 1, to = length(parameter.to.outputs), length.out = 500),,,drop = FALSE]
Rt <- aperm(Rt, names(dimnames(inf_by_region)))
stopifnot(all.equal(dim(Rt), dim(inf_by_region), check.names = FALSE))
weighted_Rt_sum <- apply(inf_by_region * Rt, c("iteration", "date"), sum)
inf_by_day <- apply(inf_by_region, c("iteration", "date"), sum)
stopifnot(all.equal(dim(weighted_Rt_sum), dim(inf_by_day)))
overall_Rt <- weighted_Rt_sum / inf_by_day
```


```{r plot-function}
make.plots <- function(projections, ylab = "", by = NULL, data = NULL,
                       y.format = ".3s", combine.to.England = sum.all,
                       combine.data.to.England = sum.all.data,
                       project.forwards = !is.null(data)) {

  projections <- get.aggregated.quantiles(projections, by, c(0.025, 0.5, 0.975)) %>%
    rename(by = all_of(by))
  if (!project.forwards) {
    projections <- filter(projections, date <= ymd(date.data))
  }
  plot.names <- unique(projections$by)
  num.rows <- ceiling(length(plot.names)/2)
  plot.height <- num.rows * 420 + 150
  date <- ymd(date.data)
  lines <- list(
    list(
        type = "line", 
        y0 = 0, 
        y1 = 1, 
        yref = "paper",
        x0 = ymd(date.data), 
        x1 = ymd(date.data), 
        line = list(color = "red"),
        hoverinfo = "Today"
    ),
    list(
        type = "line", 
        y0 = 0, 
        y1 = 1, 
        yref = "paper",
        x0 = ymd(20200307), 
        x1 = ymd(20200307), 
        line = list(color = "blue"),
        hoverinfo = "Lockdown"
    )
  )
  title <- function(name) {
    list(
      text = str_replace_all(name, "_", " "),
      xref = "paper",
      yref = "paper",
      yanchor = "top",
      xanchor = "left",
      x = 0.1,
      y = 0.9,
      font = list(size = 20),
      showarrow = FALSE
    )
  }
  create.subplot <- function(projections, subplot_title, data) {
    plot <- projections %>%
      pivot_wider(names_from = quantile) %>%
      plot_ly(x = ~date, width = 800, height = plot.height) %>%
      add_ribbons(ymin = ~`0.025`, ymax = ~`0.975`, color = I("lightblue2"), alpha = 0.25,
                hovertemplate = paste0("%{x}: %{y:", y.format, "}<extra>Upper 95% CrI</extra>")) %>%
      add_lines(y = ~`0.025`, alpha = 0,   # An extra trace just for hover text
                hovertemplate = paste0("%{x}: %{y:", y.format, "}<extra>Lower 95% CrI</extra>")) %>%
      add_lines(y = ~`0.5`, color = I("black"),
                hovertemplate = paste0("%{x}: %{y:", y.format, "}<extra>Median</extra>")) %>%
      layout(shapes = lines, annotations = title(subplot_title), showlegend = FALSE,
             hovermode = "x unified")
    if (is.null(data)) return(plot)
    plot %>%
        add_markers(
          data = data,
          x = ~date,
          y = ~True,
          color = I("red"),
          hovertemplate = "%{x}: %{y:.3s}<extra>Actual report</extra>"
        )
  }
  plots <- NULL
  for(subplot in plot.names) {
    if (is.null(data)) {
      plot.data <- NULL
    } else {
      plot.data <- data %>%
        filter(!!sym(by) == subplot) %>%
        group_by(date) %>%
        summarise(True = sum(value))
    }
    plots[[subplot]] <- projections %>%
      filter(by == subplot) %>%
      create.subplot(subplot, plot.data)
  }
  return(subplot(plots, nrows = num.rows))
}
```

## Summary

Real-time tracking of an epidemic, as data accumulate over time, is an essential component of a public health response to a new outbreak. A team of statistical modellers at the MRC Biostatistics Unit (BSU), University of Cambridge, are working with Public Health England (PHE) to regularly nowcast and forecast COVID-19 infections and deaths. This information feeds directly to the SAGE sub-group, Scientific Pandemic Influenza sub-group on Modelling (SPI-M), and to regional PHE teams.

The work uses a transmission model, data on daily COVID-19 confirmed deaths by age, and published information on the risk of dying and the time from infection to death, to reconstruct the number of new COVID-19 infections over time; estimate a measure of ongoing transmission (R); and predict the number of new COVID-19 deaths in different regions and age groups.

Note that this work reconstructs the epidemic from data, and differs from other modelling approaches that rather provide possible epidemic scenarios which are more useful for longer-term epidemic planning. 


The estimated number of infections in each age group are derived through the use of a model that tracks the susceptible fraction of the population and uses contact survey data that describe relative rates of contacts between different age groups [Mossong et al. 2008](https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0050074). Data from Google on changes in peopleâ€™s mobility and a time use survey then help to inform us on how these contact rates change over time, particularly after the lockdown.


## Key values {.tabset}

### Current R

Value of $R_e$, the average number of secondary infections due to a typical infection today.

```{r Rt-table}
get.aggregated.quantiles(Rt, "region", QUANTILES) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data)) %>%
  select(Region = region, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`) %>%
  datatable() %>%
  formatRound(2:4)

```

### Number of infections

```{r cum-inf-sum}
format_num <- function(x) {
  return(format(signif(x, 3), big.mark = ",", scientific = FALSE, width = 0))
}

tbl_cum_inf_region <-
  get.aggregated.quantiles(cum_infections, "region", c(0.025, 0.5, 0.975)) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data))
  
tbl_inf_region <- get.aggregated.quantiles(infections, "region", c(0.025, 0.5, 0.975)) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data)) %>%
  mutate_at(vars(`0.025`, `0.5`, `0.975`), format_num) %>%
  transmute(
    Region = region,
    Daily_infections = paste0(`0.5`, " (", `0.025`, "--", `0.975`, ")")
  )

```

```{r cum-inf-disp}
tbl_cum_inf_region %>%
  mutate_at(vars(`0.025`, `0.5`, `0.975`), format_num) %>%
  transmute(
    Region = region,
    Cumulative_infections = paste0(`0.5`, " (", `0.025`, "--", `0.975`, ")")
  ) %>%
  left_join(tbl_inf_region, by = "Region") %>%
  datatable()
```

### Attack rate {.tabset}

The percentage of a given group that has been infected.

#### By region

```{r attack-region}
population %>%
  group_by(region) %>%
  summarise(population = sum(value)) %>%
  left_join(tbl_cum_inf_region, by = c('region' = 'region')) %>%
  select(Region = region, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`, population) %>%
  mutate(
    Median = Median / population,
    `95% CrI (lower)` = `95% CrI (lower)` / population,
    `95% CrI (upper)` = `95% CrI (upper)` / population
    ) %>%
  select(-population) %>%
  datatable() %>%
  formatPercentage(2:4)
```


#### By age

```{r attack-age}
tbl_cum_inf_age <-
  get.aggregated.quantiles(cum_infections, "age", c(0.025, 0.5, 0.975)) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data)) %>%
  select(age, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`) 

population %>%
  group_by(age) %>%
  summarise(population = sum(value)) %>%
  left_join(tbl_cum_inf_age, by = c('age' = 'age')) %>%
  mutate(
    Median = Median / population,
    `95% CrI (lower)` = `95% CrI (lower)` / population,
    `95% CrI (upper)` = `95% CrI (upper)` / population
    ) %>%
  select(-population) %>%
  arrange(match(age, age.labs)) %>%
  datatable() %>%
  formatPercentage(2:4)
```
<!--
```{r attack-region-age}
tbl_cum_inf_region <-
  get.aggregated.quantiles(cum_infections, "region", c(0.025, 0.5, 0.975)) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data)) %>%
  select(Region = region, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`) 
population %>%
  group_by(region) %>%
  summarise(population = sum(value)) %>%
  left_join(tbl_cum_inf_region, by = c('region' = 'Region')) %>%
  #mutate_at(vars(-c(region, population)), function(x, pop) {x / pop}, population)
  mutate(
    Median = 100 * Median / population,
    `95% CrI (lower)` = 100 * `95% CrI (lower)` / population,
    `95% CrI (upper)` = 100 * `95% CrI (upper)` / population
    ) %>%
  select(-population) %>%
  knitr::kable()
```
-->

### IFR


```{r ifr, eval=!is.null(dth.dat)}
today_cum_inf_by_age <- apply(infections[,ymd(date.data)-start.date,,], c("age", "iteration"), sum)
merge.youngest.age.groups <- function(mat, num.to.group = 2) {
  add.function <- function(x) {
    to.merge <- x[1:num.to.group]
    to.preserve <- x[(num.to.group+1):length(x)]
    return(c(sum(to.merge), to.preserve))
  }
  result <- apply(mat, "iteration", add.function)
  return(result)
}

overall_ifr <- today_cum_inf_by_age %>%
  merge.youngest.age.groups() %>%
  t() %>%
  `*`(params$prop_case_to_hosp[parameter.to.outputs,]) %>%
  rowSums() %>%
  `/`(colSums(today_cum_inf_by_age)) %>%
  quantile(QUANTILES) %>%
  enframe(name = "quantile") %>%
  mutate(age = "Overall")

params$prop_case_to_hosp %>%
  as.matrix() %>%
  `colnames<-`(dimnames(deaths)$age) %>%
  as_tibble() %>%
  pivot_longer(everything(), names_to = 'age', values_to = 'ifr') %>%
  group_by(age) %>%
  summarise(value = list(quantile(ifr, QUANTILES))) %>%
  mutate(quantile = list(names(value[[1]]))) %>%
  unnest(c(quantile, value)) %>%
  bind_rows(overall_ifr) %>%
  mutate(
    quantile = parse.percentage(quantile),
    value = paste0(signif(100 * value, 2), "%")
  ) %>%
  pivot_wider(names_from = quantile, values_from = value) %>%
  select(Age = age, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`) %>%
  arrange(match(Age, c("Overall", dimnames(deaths)$age))) %>%
  datatable()

# (params$prop_case_to_hosp %>%
#   as.matrix() %>%
#   `colnames<-`(dimnames(deaths)$age) %>%
#   as_tibble() %>%
#   pivot_longer(everything(), names_to = 'age', values_to = 'ifr') %>%
#   mutate(age = factor(age, levels = dimnames(deaths)$age)) %>%
#   ggplot(aes(x = age, y = ifr)) +
#   geom_violin()) %>%
#   ggplotly()
#   
# params$prop_case_to_hosp %>%
#   as.matrix() %>%
#   `colnames<-`(dimnames(deaths)$age) %>%
#   as_tibble() %>%
#   pivot_longer(everything(), names_to = 'age', values_to = 'ifr') %>%
#   group_by(age) %>%
#   summarise(value = list(quantile(ifr, c(0.025, 0.25, 0.5, 0.75, 0.975)))) %>%
#   mutate(quantile = list(names(value[[1]]))) %>%
#   unnest(c(quantile, value)) %>%
#   mutate(
#     age = factor(age, levels = dimnames(deaths)$age),
#     quantile = parse.percentage(quantile)
#   ) %>%
#   pivot_wider(names_from = quantile, values_from = value, names_prefix = "q") %>%
#   ggplot(aes(x = age, lower=q0.25, upper=q0.75, middle=q0.5, ymin=q0.025, 
#                     ymax=q0.975)) +
#   geom_boxplot(stat = "identity") +
#   scale_y_continuous()
```

### Change in infections incidence {.tabset}

#### Growth rates

```{r growth-rate-func}
today.int <- as.integer(ymd(date.data))
wanted.days <- as.character(c(today.int - 1, today.int, today.int + 1))
calc.growth.rate <- function(data) {
  data %>%
    aperm(c("date", "region", "iteration", "age")) %>%
    `[`(wanted.days,,,,drop = FALSE) %>%
    apply(c("region", "iteration", "date"), sum) %>%
    as.tbl_cube(met_name = "value") %>%
    as_tibble() %>%
    mutate(
      date = lubridate::as_date(date)
    ) %>%
    arrange(date) %>%
    group_by(region, iteration) %>%
    summarise(growth = ((lead(value) - lag(value)) / (2 * value))[2]) %>%
    group_by(region) %>%
    summarise(Median = median(growth),
              `95% CrI (lower)` = quantile(growth, 0.025),
              `95% CrI (upper)` = quantile(growth, 0.975),
              ) %>%
    mutate(Region = str_replace_all(region, "_", " ")) %>%
    select(Region, everything()) %>%
    select(-region)
}
infections.growth.rates <- calc.growth.rate(infections)
if (!is.null(deaths)) deaths.growth.rates <- calc.growth.rate(deaths)
```

NB: negative growth rates are decline rates. Values are daily changes.

`r knitr::kable(infections.growth.rates, digits = 2, align = 'lccc')`

#### Halving times

Halving times in days, if a region shows growth than value will be Inf.

```{r inf-halving}

infections.growth.rates %>%
  mutate_at(
    vars(-'Region'),
    ~ifelse(. > 0, Inf, -1/log2(1+.))
  ) %>%
  knitr::kable(digits = 2, align = 'lccc')

```

### Change in deaths incidence {.tabset}


#### Growth rates

NB: negative growth rates are decline rates. Values are daily changes.

```{r death-growth, eval=!is.null(deaths)}
knitr::kable(deaths.growth.rates, digits = 2, align = 'lccc')
```

#### Halving times

Halving times in days, if a region shows growth than value will be Inf.

```{r death-halving, eval=!is.null(deaths)}

deaths.growth.rates %>%
  mutate_at(
    vars(-'Region'),
    ~ifelse(. > 0, Inf, -1/log2(1+.))
  ) %>%
  knitr::kable(digits = 2, align = 'lccc')

```


## Infections and deaths {.tabset}

The blue lines show when interventions have been introduced (lockdown on 7 Mar), and the red line shows the date these results were produced (`r format(ymd(date.data), "%d %b")`).

### Infection incidence {.tabset}

#### By region
```{r}
make.plots(infections, by = "region")
```

#### By age
```{r}
make.plots(infections, by = "age")
```

### Cumulative infections {.tabset}

#### By region
```{r}
make.plots(cum_infections, by = "region")
```

#### By age
```{r}
make.plots(cum_infections, by = "age")
```

```{r eval=!is.null(dth.dat), child='deaths-report.Rmd'}
```


```{r eval=!is.null(hosp.dat), child='hosp-report.Rmd'}
```

### Rt
```{r}
get.combined.Rt <- function(...) overall_Rt
make.plots(Rt, by = "region", y.format = ".2f")
```

<!--
## Methods {.tabset}

### Overview

Model figure here

### Transmission

SEIR model parameterisation

### Contact matrices

How we account for the lockdown

### Disease Severity

What proportion of infections will lead to death

### Disease Reporting

When will we know about the deaths, relative to disease onset.


-->

