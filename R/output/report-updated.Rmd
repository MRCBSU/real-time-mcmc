---
title: 'COVID-19: nowcast and forecast'
author: "Paul Birrell, Joshua Blake, Edwin van Leeuwen, MRC Biostatistics Unit COVID-19 Working Group, Daniela De Angelis."
date: "`r lubridate::today()`"
output:
  html_document:
    self_contained: no
---

<base target="_parent">

```{r preamble, include=FALSE}
if (!exists("external")) external = T
knitr::opts_chunk$set(echo = FALSE, cache.path = "~/tmp/cache")
QUANTILES <- c(0.025, 0.5, 0.975)

suppressMessages(library(knitr))
suppressMessages(library(DT))
suppressMessages(library(lubridate))
suppressMessages(library(plotly))
suppressMessages(library(tidyverse))
if(exists("Rfile.loc")) {
  source(file.path(Rfile.loc, "results_api.R"))
} else {
  proj.dir <- "~/RTM"
  source("results_api.R")
}
results_hash = tools::md5sum(file.path(out.dir, "output_matrices.RData"))
if (external && exists("dth.dat")) {
	dth.dat <- filter(dth.dat, date <= ymd(date.data) - reporting.delay)
	results_hash = NULL
}
if (!exists("prev.dat")) prev.dat <- NULL

```


```{r plot-function}
title <- function(name) {
  list(
    text = str_replace_all(name, "_", " "),
    xref = "paper",
    yref = "paper",
    yanchor = "top",
    xanchor = "left",
    x = 0.1,
    y = 0.9,
    font = list(size = 20),
    showarrow = FALSE
  )
}

create.base.subplot <- function(data, num.rows, subplot_title) {
  lines <- list(
    list(
        type = "line", 
        y0 = 0, 
        y1 = 1, 
        yref = "paper",
        x0 = ymd(date.data), 
        x1 = ymd(date.data), 
        line = list(color = "red"),
        hoverinfo = "Today"
    ),
    list(
        type = "line", 
        y0 = 0, 
        y1 = 1, 
        yref = "paper",
        x0 = ymd(20200323), 
        x1 = ymd(20200323), 
        line = list(color = "blue"),
        hoverinfo = "Lockdown"
    ),
    list(
        type = "line", 
        y0 = 0, 
        y1 = 1, 
        yref = "paper",
        x0 = ymd(20200511), 
        x1 = ymd(20200511), 
        line = list(color = "blue"),
        hoverinfo = "Lockdown"
    )
  )
  lines <- lines[sapply(lines, function(x) x$x0 %in% data$date)]
  plot.height <- num.rows * 420 + 150
  return(
    plot_ly(data, x = ~date, width = 800, height = plot.height) %>%
      layout(shapes = lines, annotations = title(subplot_title), showlegend = FALSE,
             hovermode = "x unified")
  )
}

make.plots <- function(projections, ylab = "", by = NULL, data = NULL,
                       y.format = ".3s", combine.to.England = sum.all,
                       combine.data.to.England = sum.all.data,
                       project.forwards = !is.null(data), x.label = "") {

  if (is.null(combine.to.England)) {
    Eng_projection <- Eng_data <- NULL
  } else {
    Eng_projection <- combine.to.England(projections) %>% add.quantiles(NULL, QUANTILES)
    Eng_data <- combine.data.to.England(data)
  }
  projections <- get.aggregated.quantiles(projections, by, c(0.025, 0.5, 0.975)) %>%
    rename(by = all_of(by))
  if (!project.forwards) {
    if (!is.null(Eng_projection)) {
      Eng_projection <- filter(Eng_projection, date <= ymd(date.data))
    }
    projections <- filter(projections, date <= ymd(date.data))
  }
  plot.names <- unique(projections$by)
  num.plots <- length(plot.names)
  if (!is.null(Eng_projection)) num.plots <- num.plots + 1
  num.rows <- ceiling(num.plots/2)
  date <- ymd(date.data)
  create.subplot <- function(projections, subplot_title, data) {
    plot <- projections %>%
      pivot_wider(names_from = quantile) %>%
      create.base.subplot(num.rows, subplot_title) %>%
      add_ribbons(ymin = ~`0.025`, ymax = ~`0.975`, color = I("lightblue2"), alpha = 0.25,
                hovertemplate = paste0("%{x}: %{y:", y.format, "}<extra>Upper 95% CrI</extra>")) %>%
      add_lines(y = ~`0.025`, alpha = 0,   # An extra trace just for hover text
                hovertemplate = paste0("%{x}: %{y:", y.format, "}<extra>Lower 95% CrI</extra>")) %>%
      add_lines(y = ~`0.5`, color = I("black"),
                hovertemplate = paste0("%{x}: %{y:", y.format, "}<extra>Median</extra>")) %>%
      layout(xaxis = list(title = x.label))
    if (is.null(data)) {
      return(plot)
    } else {
      if (external) {
        data.hover <- "%{x} <extra>Observed deaths</extra>"
      } else {
        data.hover <- "%{x}: %{y:.3s}<extra>Observed deaths</extra>"
      }
      plot %>%
        add_markers(
          data = data,
          x = ~date,
          y = ~True,
          color = I("red"),
          hovertemplate = data.hover
        )
    }
  }
  plots <- NULL
  if (!is.null(Eng_projection)) plots <- list("England" = create.subplot(Eng_projection, "England", Eng_data))
  for(subplot in plot.names) {
    if (is.null(data)) {
      plot.data <- NULL
    } else {
      plot.data <- data %>%
        filter(!!sym(by) == subplot) %>%
        group_by(date) %>%
        summarise(True = sum(value))
    }
    plots[[subplot]] <- projections %>%
      filter(by == subplot) %>%
      create.subplot(subplot, plot.data)
  }
  return(subplot(plots, nrows = num.rows))
}
```

## {.tabset}

```{r eval=external, child='updates.Rmd'}
```

### Summary

Real-time tracking of an epidemic, as data accumulate over time, is an essential component of a public health response to a new outbreak. A team of statistical modellers at the MRC Biostatistics Unit (BSU), University of Cambridge, are working to provide regular now-casts and forecasts of COVID-19 infections and deaths. This information feeds directly to the SAGE sub-group, Scientific Pandemic Influenza sub-group on Modelling (SPI-M), and to regional Public Health England (PHE) teams.

### Methods

We fit a transmission model ([Birrell et al. 2020](https://www.medrxiv.org/content/10.1101/2020.08.24.20180737v1)) to a number of data sources (see 'Data Sources'), to  reconstruct the number of  new COVID-19 infections over time in different age groups and NHS regions, estimate a measure of ongoing transmission and predict the number of new COVID-19 deaths.

### Data sources

We use:
  
1. Data on COVID-19 confirmed deaths from the Public Health England (PHE) line-listing   This consists of a combination of deaths notified to:
    * the Demographics Batch Service (DBS), a mechanism that allows PHE to submit a file of patient information to the National Health Service spine for tracing against the personal demographics service (PDS). PHE submit a line list of patients diagnosed with COVID-19 to DBS daily. The file is returned with a death flag and date of death updated (started 20th March, 2020).
    * NHS England, who report data from NHS trusts relating to patients who have died after admission to hospital or within emergency department settings.
    * Health Protection Teams (HPTs), resulting from a select survey created by PHE to capture deaths occurring outside of hospital settings, e.g. care homes (started 23rd March, 2020)
2. Data on antibody prevalence in blood samples from a PHE survey of NHS Blood Transfusion (NHSBT) donors.

Data are stratified into eight age groups: <1, 1-4, 5-14, 15-24, 25-44, 45-64, 65-74, 75+, and the NHS England regions (North East and Yorkshire, North West, Midlands, East of England, London, South East, South West).

3. Published information on the the natural history of COVID-19 ([Verity et al., 2020](https://www.thelancet.com/journals/laninf/article/PIIS1473-3099%2920%2930243-7/abstract); [Li et al, 2020](https://www.nejm.org/doi/10.1056/NEJMoa2001316)) 
4. Information on contacts between different age groups from:
    * A Survey that describes relative rates of contacts between different age groups ([Mossong et al. 2008](https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0050074)).
    * [Google Community Mobility reports](https://www.google.com/covid19/mobility/), informing the  changes in people’s mobility over the course of the pandemic, particularly after the March 23rd lockdown measures.
    * [The ONS’ time use survey](https://beta.ukdataservice.ac.uk/datacatalogue/studies/study?id=8128), which in conjunction with the google mobility study, allows estimation of the changing exposure to infection risk over time.
    * Data from the Department for Education describing the proportion of children currently attending school.


## Epidemic summary {.tabset}

### Current $R_t$

Value of $R_t$, the average number of secondary infections due to a typical infection today.

```{r Rt-table}
get.aggregated.quantiles(Rt, "region", QUANTILES) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data)) %>%
  select(Region = region, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`) %>%
  datatable() %>%
  formatRound(2:4)

```

### Number of infections

```{r cum-inf-sum}
format_num <- function(x) {
  return(format(round(signif(x, 3)), big.mark = ",", scientific = FALSE, width = 0))
}

tbl_cum_inf_region <-
  get.aggregated.quantiles(cum_infections, "region", c(0.025, 0.5, 0.975)) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data))
  
tbl_ar_Eng <- get.aggregated.quantiles(cum_infections, NULL, c(0.025, 0.5, 0.975))  %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data)) %>%
  mutate(
    population = sum(population$value),
    region = "England"
  )

tbl_inf_region <-
  bind_rows(
    get.aggregated.quantiles(infections, NULL, c(0.025, 0.5, 0.975))  %>%
    pivot_wider(names_from = quantile) %>%
    filter(date == ymd(date.data)) %>%
    mutate(
      region = "England"
    ),
    get.aggregated.quantiles(infections, "region", c(0.025, 0.5, 0.975)) %>%
    pivot_wider(names_from = quantile) %>%
    filter(date == ymd(date.data))
  )%>%
  mutate_at(vars(`0.025`, `0.5`, `0.975`), format_num) %>%
  transmute(
    Region = region,
    Daily_infections = paste0(`0.5`, " (", `0.025`, "--", `0.975`, ")")
  )

```

```{r cum-inf-disp}
bind_rows(
  select(tbl_ar_Eng, -population),
  tbl_cum_inf_region
) %>%
  mutate_at(vars(`0.025`, `0.5`, `0.975`), format_num) %>%
  transmute(
    Region = region,
    Cumulative_infections = paste0(`0.5`, " (", `0.025`, "--", `0.975`, ")")
  ) %>%
  left_join(tbl_inf_region, by = "Region") %>%
  datatable()
```

### Attack rate {.tabset}

The percentage of a given group that has been infected.

#### By region

```{r attack-region}
bind_rows(
  tbl_ar_Eng,
  population %>%
    group_by(region) %>%
    summarise(population = sum(value)) %>%
    left_join(tbl_cum_inf_region, by = c('region' = 'region'))
  ) %>%
  select(Region = region, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`, population) %>%
  mutate(
    Median = Median / population,
    `95% CrI (lower)` = `95% CrI (lower)` / population,
    `95% CrI (upper)` = `95% CrI (upper)` / population
    ) %>%
  select(-population) %>%
  datatable() %>%
  formatPercentage(2:4)
```


#### By age

```{r attack-age}
tbl_cum_inf_age <-
  get.aggregated.quantiles(cum_infections, "age", c(0.025, 0.5, 0.975)) %>%
  pivot_wider(names_from = quantile) %>%
  filter(date == ymd(date.data)) %>%
  select(age, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`) 

population %>%
  group_by(age) %>%
  summarise(population = sum(value)) %>%
  left_join(tbl_cum_inf_age, by = c('age' = 'age')) %>%
  mutate(
    Median = Median / population,
    `95% CrI (lower)` = `95% CrI (lower)` / population,
    `95% CrI (upper)` = `95% CrI (upper)` / population
    ) %>%
  select(-population) %>%
  arrange(match(age, age.labs)) %>%
  datatable() %>%
  formatPercentage(2:4)
```

### IFR


```{r ifr, eval=!is.null(dth.dat)}
ifr.start <- ifr[, , 1]
ifr.today <- ifr[, , ymd(date.data) - start.date]
today_cum_inf_by_age <- apply(infections[,ymd(date.data)-start.date,,,drop = FALSE], c("age", "iteration"), sum)
merge.youngest.age.groups <- function(mat, num.to.group = 2) {
  if (num.ages <= 1) {return(mat)}
  add.function <- function(x) {
    to.merge <- x[1:num.to.group]
    to.preserve <- x[(num.to.group+1):length(x)]
    return(c(sum(to.merge), to.preserve))
  }
  result <- apply(mat, "iteration", add.function)
  return(result)
}

overall_ifr <- function(day.ifr)
  today_cum_inf_by_age %>%
    merge.youngest.age.groups() %>%
    t() %>%
    `*` (day.ifr[parameter.to.outputs, ]) %>%
    rowSums() %>%
    `/`(colSums(today_cum_inf_by_age)) %>%
    quantile(QUANTILES) %>%
    enframe(name = "quantile") %>%
    mutate(age = "Overall")

if(!single.ifr)
	overall_ifr_start <- overall_ifr(ifr.start)
overall_ifr_today <- overall_ifr(ifr.today)

ifr.table <- function(x, overall_x)
  x %>%
    as.matrix() %>%
    `colnames<-`(dimnames(deaths)$age) %>%
    as_tibble() %>%
    pivot_longer(everything(), names_to = 'age', values_to = 'ifr') %>%
    group_by(age) %>%
    summarise(value = list(quantile(ifr, QUANTILES))) %>%
    mutate(quantile = list(names(value[[1]]))) %>%
    unnest(c(quantile, value)) %>%
    bind_rows(overall_x) %>%
    mutate(
	quantile = parse.percentage(quantile),
    	value = paste0(signif(100 * value, 2), "%")
  	) %>%
    pivot_wider(names_from = quantile, values_from = value) %>%
    select(Age = age, Median = `0.5`, `95% CrI (lower)` = `0.025`, `95% CrI (upper)` = `0.975`) %>%
    arrange(match(Age, c("Overall", dimnames(deaths)$age)))

if(!single.ifr){
	ifr.table(ifr.start, overall_ifr_start) %>%
  			     inner_join(ifr.table(ifr.today, overall_ifr_today), by = "Age") %>%
  			     rename(Med_early = Median.x,
    			     		      Lower_early = `95% CrI (lower).x`,
    					      Upper_early = `95% CrI (upper).x`,
    					      Med_late = Median.y,
    					      Lower_late = `95% CrI (lower).y`,
    					      Upper_late = `95% CrI (upper).y`) %>%
   					       datatable()
} else {
  ifr.table(ifr.today, overall_ifr_today) %>%
  		       datatable()
}

# (params$prop_case_to_hosp %>%
#   as.matrix() %>%
#   `colnames<-`(dimnames(deaths)$age) %>%
#   as_tibble() %>%
#   pivot_longer(everything(), names_to = 'age', values_to = 'ifr') %>%
#   mutate(age = factor(age, levels = dimnames(deaths)$age)) %>%
#   ggplot(aes(x = age, y = ifr)) +
#   geom_violin()) %>%
#   ggplotly()
#   
# params$prop_case_to_hosp %>%
#   as.matrix() %>%
#   `colnames<-`(dimnames(deaths)$age) %>%
#   as_tibble() %>%
#   pivot_longer(everything(), names_to = 'age', values_to = 'ifr') %>%
#   group_by(age) %>%
#   summarise(value = list(quantile(ifr, c(0.025, 0.25, 0.5, 0.75, 0.975)))) %>%
#   mutate(quantile = list(names(value[[1]]))) %>%
#   unnest(c(quantile, value)) %>%
#   mutate(
#     age = factor(age, levels = dimnames(deaths)$age),
#     quantile = parse.percentage(quantile)
#   ) %>%
#   pivot_wider(names_from = quantile, values_from = value, names_prefix = "q") %>%
#   ggplot(aes(x = age, lower=q0.25, upper=q0.75, middle=q0.5, ymin=q0.025, 
#                     ymax=q0.975)) +
#   geom_boxplot(stat = "identity") +
#   scale_y_continuous()
```

### Change in infections incidence {.tabset}

#### Growth rates

```{r growth-rate-func}
signed_inf <- function(num) {
  ifelse(
    num == 0, 0,
    ifelse(num > 0, +Inf, -Inf)
  )
}

add.England <- function(data) {
  sum.all(infections)
  data <- apply(infections, c("region", "iteration", "date"), sum)
  data <- aperm(data, c("date", "region", "iteration", "age"))
  data["England",,] <- apply(infections, c("iteration", "date"), sum)
}

today.int <- as.integer(ymd(date.data))
wanted.days <- as.character(c(today.int - 1, today.int, today.int + 1))
calc.growth.rate <- function(data) {
  data <- data %>%
    aperm(c("date", "region", "iteration", "age")) %>%
    `[`(wanted.days,,,,drop = FALSE)
  num.iterations <- dim(data)[3]
  data %>%
    apply(c("region", "iteration", "date"), sum) %>%
    as.tbl_cube(met_name = "value") %>%
    as_tibble() %>%
    bind_rows(
      apply(data, c("iteration", "date"), sum) %>%
      as.tbl_cube(met_name = "value") %>%
      as_tibble() %>%
      mutate(region = "England")
    ) %>%
    mutate(
      date = lubridate::as_date(date)
    ) %>%
    arrange(date, iteration) %>%
    group_by(region, iteration) %>%
    mutate(gradient = lead(value) - lag(value)) %>%
    summarise(growth = 
                ifelse(value == 0,
                       signed_inf(gradient),
                       gradient / (2 * value))[2]
    ) %>%
    group_by(region) %>%
    summarise(Median = median(growth),
              `95% CrI (lower)` = quantile(growth, 0.025),
              `95% CrI (upper)` = quantile(growth, 0.975)
              ) %>%
    arrange(match(region, c("England", regions))) %>%
    mutate(Region = str_replace_all(region, "_", " ")) %>%
    select(Region, everything()) %>%
    select(-region)
}
infections.growth.rates <- calc.growth.rate(infections)
if (!is.null(deaths)) deaths.growth.rates <- calc.growth.rate(deaths)
```

NB: negative growth rates are rates of decline. Values are daily changes.

`r knitr::kable(infections.growth.rates, digits = 2, align = 'lccc')`

#### Halving times

Halving times in days, if a region shows growth than value will be NA.

```{r inf-halving}

infections.growth.rates %>%
  mutate_at(
    vars(-'Region'),
    ~ifelse(. > 0, NA, -1/log2(1+.))
  ) %>%
  knitr::kable(digits = 2, align = 'lccc')

```

#### Doubling times

Doubling times in days, if a region shows decline then the value will be NA.

```{r inf-doubling}

infections.growth.rates %>%
  mutate_at(
    vars(-'Region'),
    ~ifelse(. < 0, NA, log(2)/(.))
  ) %>%
  rename(tmp = `95% CrI (upper)`) %>%
  rename(`95% CrI (lower)` = tmp,
  	 `95% CrI (upper)` = `95% CrI (lower)`) %>%
  select(Region, Median, `95% CrI (lower)`, `95% CrI (upper)`) %>%
  knitr::kable(digits = 2, align = 'lccc')
    
```

### Change in deaths incidence {.tabset}


#### Growth rates

NB: negative growth rates are rates of decline. Values are daily changes.

```{r death-growth, eval=!is.null(deaths)}
knitr::kable(deaths.growth.rates, digits = 2, align = 'lccc')
```

#### Halving times

Halving times in days, if a region shows growth than value will be NA.

```{r death-halving, eval=!is.null(deaths)}

deaths.growth.rates %>%
  mutate_at(
    vars(-'Region'),
    ~ifelse(. > 0, NA, -1/log2(1+.))
  ) %>%
  knitr::kable(digits = 2, align = 'lccc')

```

#### Doubling times

Doubling times in days, if a region shows decline then the value will be NA.

```{r death-doubling, eval=!is.null(deaths)}

deaths.growth.rates %>%
  mutate_at(
    vars(-'Region'),
    ~ifelse(. < 0, NA, log(2)/(.))
  ) %>%
  rename(tmp = `95% CrI (upper)`) %>%
  rename(`95% CrI (lower)` = tmp,
  	 `95% CrI (upper)` = `95% CrI (lower)`) %>%
  select(Region, Median, `95% CrI (lower)`, `95% CrI (upper)`) %>%
  knitr::kable(digits = 2, aligh = 'lccc')
```

## Infections and deaths {.tabset}

The blue lines is show when interventions have been introduced (lockdown on 23 Mar and the relaxation of measures on 11 May), and the red line shows the date these results were produced (`r format(ymd(date.data), "%d %b")`).

```{r eval=!is.null(prev.dat), child='prev-report.Rmd'}
```

```{r eval=!is.null(case.dat), child='hosp-report.Rmd'}
```

### Infection incidence {.tabset}

#### By region
```{r reg-inf, cache=TRUE, cache.extra=results_hash}
make.plots(infections, by = "region")
```

#### By age
```{r age-inf, cache=TRUE, cache.extra=results_hash}
make.plots(infections, by = "age")
```

### Cumulative infections {.tabset}

#### By region
```{r reg-cum-inf-reg, cache=TRUE, cache.extra=results_hash}
make.plots(cum_infections, by = "region")
```

#### By age
```{r r-cum-inf-age, cache=TRUE, cache.extra=results_hash}
make.plots(cum_infections, by = "age")
```

```{r eval=!is.null(dth.dat), child='deaths-report.Rmd'}
```



### Prob $R_t > 1$

The figure below shows the probability that $R_t$ is greater than 1 (ie: the number of infections is growing) in each region over time.
Clicking the regions in the legend allows lines to be added or removed from the figure.

```{r P-R-gt-1, cache=TRUE, cache.extra=results_hash}
(Rt > 1) %>%
  apply(c("date", "region"), sum) %>%
  `/`(length(dimnames(Rt)$iteration)) %>%
  as.tbl_cube(met_name = "value") %>%
  as_tibble() %>%
  mutate(date = as_date(date)) %>%
  filter(date <= ymd(date.data)) %>%
  create.base.subplot(1, "") %>%
  add_lines(y = ~value, x = ~date, color = ~region) %>%#, hovertemplate = "%{y:.2r}") %>%
  layout(showlegend = TRUE, yaxis = list(tickformat = "%", title = "$\\text{Probability }R_t > 1$"),
         xaxis = list(title = "Date"))
```

### $R_t$
```{r Rt-plot, cache=TRUE, cache.extra=results_hash}
make.plots(Rt, by = "region", y.format = ".2f", combine.to.England = NULL)
```

```{r eval=(!external & file.exists(file.path(out.dir, "projections.RData"))), child='projinf-report.Rmd'}
```

```{r eval=(!external & as.logical(gp.flag) & file.exists(file.path(out.dir, "projections.RData"))), child='projinf-cases-report.Rmd'}
```


# 

Copyright © MRC Biostatistics Unit, University of Cambridge
