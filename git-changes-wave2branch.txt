diff --git a/R/output/R b/R/output/R
deleted file mode 100644
index e69de29bb..000000000
diff --git a/R/output/chain_comparison.R b/R/output/chain_comparison.R
index e9c46719a..df720c637 100644
--- a/R/output/chain_comparison.R
+++ b/R/output/chain_comparison.R
@@ -23,8 +23,8 @@ thisFile <- function() {
 Rfile.loc <- dirname(thisFile())
 source(file.path(Rfile.loc, "drw.R"))
 
-colcode.fl <- "./Prev585SeroNHSBT_All_NHS28cutoff_IFR6bp_18wk2_prev14-0PHE_matrices_20211210_stable_household_deaths"
-oldcode.fl <- "./Prev585SeroNHSBT_All_NHS28cutoff_IFR6bp_18wk2_prev14-0PHE_matrices_20211210_stable_household_deaths_chain2"
+colcode.fl <- "./Prev375SeroNHSBT_All_ONS60cutoff_IFR4bp_18wk2_prev14-0PHE_matrices_20210514_timeuse_household_deaths"
+oldcode.fl <- "./Prev375SeroNHSBT_All_ONS60cutoff_IFR4bp_18wk2_prev14-0PHE_matrices_20210514_timeuse_household_deaths_chain2"
 
 ## load("mcmc.RData")
 load(file.path(colcode.fl, "tmp.RData"))
diff --git a/R/output/mc_snapshot_forecast.R b/R/output/mc_snapshot_forecast.R
index 412392654..e35e01c9a 100644
--- a/R/output/mc_snapshot_forecast.R
+++ b/R/output/mc_snapshot_forecast.R
@@ -5,7 +5,7 @@ require(abind)
 require(parallel)
 require(knitr)
 
-out.dir <- "./" ## commandArgs(trailingOnly = TRUE)[1]
+out.dir <- commandArgs(trailingOnly = TRUE)[1]
 QUANTILES <- c(0.025, 0.5, 0.975)
 ## out.dir <- as.integer(Sys.getenv("SLURM_ARRAY_TASK_ID"))
 if (!is.na(out.dir)) setwd(out.dir)
@@ -19,8 +19,7 @@ projections.basename <- "projections_snapshot"
 projections.basedir <- file.path(out.dir, projections.basename)
 
 ## Enter the date for which we need the snapshot
-snap.date <- ymd("20211208")
-
+snap.date <- ymd("20211026")
 
 ## ---------------- IDEALLY CODE BELOW HERE SHOULD NOT BE CHANGED BETWEEN RUNS
 if(!file.exists(projections.basedir))
@@ -35,6 +34,8 @@ end.hosp <- ifelse(hosp.flag, ndays, 1)
 end.gp <- ifelse(gp.flag, ndays, 1)
 end.prev <- ifelse(prev.flag, ndays, 1)
 end.vac <- ifelse(vacc.flag, ndays, 1)
+if(start.sero > ndays) sero.flag <- 0
+end.sero <- ifelse(sero.flag, ndays, 1)
 
 ## REMOVE ANY UNNECESSARY CONTACT MATRICES
 cm.flags <- c(TRUE, cm.breaks < ndays)
@@ -49,12 +50,14 @@ if(!all(file.exists(cm.mults)))
 repeat.last.row <- function(real.fl, dummy.fl){
     tmpdata <- read_tsv(real.fl, col_names = FALSE)
     dummy.fl <- file.path(projections.basedir, paste0(dummy.fl, ".txt"))
+    if(ndays > nrow(tmpdata)){
     tmpdata <- bind_rows(tmpdata,
                          tmpdata[rep(nrow(tmpdata), ndays - nrow(tmpdata)), ]) %>%
             mutate(Date = start.date - 1 + (1:ndays)) %>%
             select(-X1) %>%
             select(Date, everything()) %>%
             write_tsv(dummy.fl, col_names = FALSE)
+    } else write_tsv(tmpdata[1:ndays, ], dummy.fl, col_names = FALSE)
     return(dummy.fl)
 }
 
@@ -94,13 +97,132 @@ knit(input = inputs.template.loc, output = file.path(projections.basedir, "mod_i
 ## ## ## CHANGES NECESSARY FOR THE mod_pars.Rmd TEMPLATE
 
 ## ## Will need to remove temporal breakpoints and rows from design matrices
-vac.rows.remove <- function(t0, nr.levels, na.levels, t.breaks){
-    nt.levels <- length(t.breaks) + 1
-    tot.rows <- nr.levels * na.levels * t.levels
-    fac.grid <- expand.grid(1:na.levels, 1:nt.levels, 1:nr.levels)
-    ## which levels do we want to keep...
+vac.rows.remove <- function(t0, nr.levels, na.levels, t.levels){
+    nt.levels <- length(t.levels)
+    tot.rows <- nr.levels * na.levels * nt.levels
+    as_tibble(expand.grid(1:na.levels, t.levels, 1:nr.levels)) %>%
+        ## which levels do we want to keep...
+        mutate(include = Var2 <= t.levels[t0]) %>%
+        pull(include)
+}
+copy.design <- function(design)
+    file.copy(file.path(out.dir, design), projections.basedir)
+symlink.design <- function(design)
+    file.symlink(file.path(out.dir, design), projections.basedir)
+## Select only relevant rows from the original design matrix according to the desired timepoint.
+select.design <- function(design, breaks, t0, nreg = nr, nA = nA){
+    ## read in the original design matrix
+    des <- read_tsv(file.path(out.dir, design), col_names = FALSE)
+    ## how many of the temporal breakpoints are actually active
+    nbg <- sum(breaks < t0)
+    ## which rows of the original design matrix will we now have to remove
+    bg.include <- vac.rows.remove(nbg + 1, nreg, nA, 1:(length(breaks) + 1))
+    ## return only the rows we want from the original design
+    des[bg.include, ]
+}
+
+## ## Copy across the original design matrices
+if(gp.flag)
+    symlink.design("icr.design.txt")
+if(rw.flag)
+    symlink.design("m.design.txt")
+if(beta.rw.flag){
+    ## Can we use the pre-existing matrix?
+    if(max(beta.breaks) < ndays){ ## yes
+        symlink.design("beta.design.txt")
+    } else {
+        select.design("beta.design.txt", beta.breaks, ndays, nA = 1) %>%
+            write_tsv(path = file.path(projections.basedir, "beta.design.txt"), col_names = FALSE)
+        beta.breaks <- beta.breaks[beta.breaks < ndays]
+        ## des <- read_tsv(file.path(out.dir, "beta.design.txt"), col_names = FALSE)
+        ## nbg <- sum(beta.breaks < ndays)
+        ## bg.include <- vac.rows.remove(nbg + 1, nr, 1, 1:(length(beta.breaks) + 1))
+        ## write_tsv(des[bg.include, ], path = file.path(projections.basedir, "beta.design.txt"), col_names = FALSE)
+    }
 }
-## Vaccine efficacy parameters - full age/time/region dependency.
-vac.rows.remove
+if(!single.ifr){
+    ## Can we use the pre-existing matrix?
+    if(max(tbreaks.ifr) < ndays){
+        symlink.design("ifr.design.txt")
+    } else {
+        select.design("ifr.design.txt", tbreaks.ifr, ndays, nr = 1, nA = nA - 1) %>%
+            write_tsv(path = file.path(projections.basedir, "ifr.design.txt"), col_names = FALSE)
+        tbreaks.ifr <- tbreaks.ifr[tbreaks.ifr < ndays]
+    }
+}
+if(vacc.flag){
+    ## Can we use the pre-existing design matrix?
+    if(max(vac.effec.bp) < ndays){
+        symlink.design("vac.pi1.design.txt")
+        symlink.design("vac.pin.design.txt")
+        symlink.design("vac.alpha1.design.txt")
+        symlink.design("vac.alphan.design.txt")
+    } else {
+        mat1 <- select.design("vac.pi1.design.txt", vac.effec.bp, ndays, nr, nA)
+        matn <- select.design("vac.pin.design.txt", vac.effec.bp, ndays, nr, nA)
+        write_tsv(mat1, path = file.path(projections.basedir, "vac.pi1.design.txt"), col_names = FALSE)
+        write_tsv(mat1, path = file.path(projections.basedir, "vac.alpha1.design.txt"), col_names = FALSE)
+        write_tsv(matn, path = file.path(projections.basedir, "vac.pin.design.txt"), col_names = FALSE)
+        write_tsv(matn, path = file.path(projections.basedir, "vac.alphan.design.txt"), col_names = FALSE)
+        vac.effec.bp <- vac.effec.bp[vac.effec.bp < ndays]
+    }
+}
+## ## -------------------------------------
 
 ## ## ## ### ---  End of setting inputs for mod_pars.txt  --- ### ## ## ##
+
+## ## ## ### --- --- ---   MAIN PROJECTION LOOP   --- --- --- ### ## ## ##
+
+## ## Get number of iterations
+niter <- min(sapply(params, nrow))
+
+## ## For each iteration
+pct <- 0
+## xtmp <- mclapply(1:niter, sim_rtm, mc.cores = detectCores() - 1)
+if(Sys.info()["user"] %in% c("jbb50", "pjb51")){
+    exe <- "hpc2"
+} else exe <- Sys.info()["nodename"]
+cat("rtm.exe = ", exe, "\n")
+xtmp <- mclapply(1:niter, sim_rtm, mc.cores = detectCores() - 1, rtm.exe = exe)
+NNI <- lapply(xtmp, function(x) x$NNI)
+if(smc.outs){
+    state <- lapply(xtmp, function(x) x$state)
+} else {
+    Sero <- lapply(xtmp, function(x) x$Sero)
+    if(vacc.flag) DNNI <- lapply(xtmp, function(x) x$DNNI)
+    Deaths <- lapply(xtmp, function(x) x$Deaths)
+    Cases <- lapply(xtmp, function(x) x$Cases)
+    Prevs <- lapply(xtmp, function(x) x$Prevs)
+}
+rm(xtmp)
+## ## ## ###   --- --- --- --- --- --- --- --- --- --- ---   ### ## ## ##
+
+
+## ## PROCESSING OUTPUTS
+melt.list <- function(xlist)
+    abind(lapply(xlist,
+                 abind,
+                 along = 3),
+          along = 0)
+dim.list <- list(iteration = 1:niter,#niter,
+                 age = age.labs,
+                 date = paste0("t", seq(0, as.integer(ndays) - 0.5, by = 0.5)),
+                 region = regions
+                 )
+
+infections <- melt.list(NNI)## ;rm(NNI)
+dimnames(infections) <- dim.list
+state <- do.call(bind_rows, state) %>%
+    inner_join(expand_grid(regions, age.labs) %>% mutate(popn = pop.input) %>% rename(region = regions))
+state <- bind_rows(state,
+                   state %>% group_by(iteration, region, age.labs) %>%
+                   summarise(unrecovered = sum(value), popn = median(popn)) %>%
+                   mutate(value = popn - unrecovered,
+                          state.names = "R-") %>%
+                   select(-unrecovered)
+                   )
+state.lkup <- tibble(state.names = c("S", "SV1", "SV2", "E1", "E2", "I1", "I2", "R+", "R-", "plambda"), state.text = c("Fully susceptible", "Never infected, incomplete immunisation", "Never infected, complete immunisation", "Latent infection", "Latent infection", "Prevalent infection", "Prevalent infection", "Prevalent infection", "Infection-acquired immunity", "Infectious pressure"))
+state <- state %>%
+    inner_join(state.lkup)
+
+save(state, file = paste0("snapshot", snap.date, ".RData"))
diff --git a/rerun.R b/rerun.R
index 7e43ee503..2b0e6b603 100644
--- a/rerun.R
+++ b/rerun.R
@@ -31,9 +31,10 @@ if (!file.exists("mcmc.RData")) {
 }
 
 render(
-	file.path(Rfile.loc, 'report-updated.Rmd'),
-	html_document(pandoc_args = "--self-contained"),
-	output_dir = out.dir
+    file.path(Rfile.loc, 'report-updated.Rmd'),
+    html_document(pandoc_args = "--self-contained"),
+    output_dir = out.dir,
+    intermediates_dir = "~/scratch/tmp"
 )
 
 ## Return back to initial directory
diff --git a/submission_scripts/submit_ice_hpc b/submission_scripts/submit_ice_hpc
index d3698139b..e77d94316 100644
--- a/submission_scripts/submit_ice_hpc
+++ b/submission_scripts/submit_ice_hpc
@@ -13,7 +13,7 @@
 #SBATCH --no-requeue
 #SBATCH --verbose
 
-#SBATCH --array=14
+#SBATCH --array=0-1
 #SBATCH -p icelake
 #!SBATCH --qos=covid0
 
diff --git a/submission_scripts/submit_post_process b/submission_scripts/submit_post_process
index c34ce4290..19ac5a83b 100644
--- a/submission_scripts/submit_post_process
+++ b/submission_scripts/submit_post_process
@@ -17,7 +17,7 @@
 #! How many (MPI) tasks will there be in total? (<= nodes*16)
 #SBATCH --ntasks=1
 #! How many CPUs will each task require
-#SBATCH --cpus-per-task=21
+#SBATCH --cpus-per-task=22
 #! How much wallclock time will be required?
 #SBATCH --time=4:00:00
 #! What types of email messages do you wish to receive?
@@ -28,7 +28,7 @@
 #! interrupted by node failure or system downtime):
 #SBATCH --no-requeue
 #SBATCH --verbose
-#SBATCH --array=1-5,7,8,11,12
+#SBATCH --array=0-1
 
 #SBATCH -p cclake-himem
 
diff --git a/submission_scripts/submit_save_endstates b/submission_scripts/submit_save_endstates
index 7d9e4e5f4..09f7eb512 100644
--- a/submission_scripts/submit_save_endstates
+++ b/submission_scripts/submit_save_endstates
@@ -13,7 +13,7 @@
 #SBATCH --no-requeue
 #SBATCH --verbose
 
-#SBATCH --array=0,1,4-13
+#SBATCH --array=0-11
 #SBATCH -p icelake
 #!SBATCH --qos=covid0
 
diff --git a/submission_scripts/submit_simulate b/submission_scripts/submit_simulate
index e754f10bf..830c43c33 100644
--- a/submission_scripts/submit_simulate
+++ b/submission_scripts/submit_simulate
@@ -17,7 +17,7 @@
 #! How many (MPI) tasks will there be in total? (<= nodes*16)
 #SBATCH --ntasks=1
 #! How many CPUs will each task require
-#SBATCH --cpus-per-task=28
+#SBATCH --cpus-per-task=75
 #! How much wallclock time will be required?
 #SBATCH --time=1:00:00
 #! What types of email messages do you wish to receive?
@@ -28,9 +28,9 @@
 #! interrupted by node failure or system downtime):
 #SBATCH --no-requeue
 #SBATCH --verbose
-#SBATCH --array=5
+#SBATCH --array=0
 
-#SBATCH -p cclake
+#SBATCH -p icelake
 #!SBATCH --qos=covid0
 
 #! sbatch directives end here (put any additional directives above this line)
@@ -38,7 +38,7 @@
 #SBATCH --output=simulate_cclake_20211203_%a.out
 #SBATCH --error=simulate_cclake_20211203_%a.err
 
-forecast_switch="midterm"
+forecast_switch="snapshot"
 
 #! Notes:
 #! Charging is determined by node number*walltime. Allocation is in entire nodes.
diff --git a/switch.comp.R b/switch.comp.R
index b905d560d..8c38fc009 100644
--- a/switch.comp.R
+++ b/switch.comp.R
@@ -19,8 +19,8 @@ out.repo <- "20210930_nth"
 ## Change location of output directory
 ## in.base <- "PrevINLAnew515_cm6ons_IFR5bp_ONS60cutoff_18wk2_prev14-0PHE_matrices_20211001_timeuse_household_new_base_deaths"
 ## out.base <- "ONS60"
-in.base <- "20211001_1st"
-out.base <- "20210930_1st"
+in.base <- "chain3_chain3"
+out.base <- "chain3" 
 
 ## Get all variable names
 var.list <- eapply(setup.env, typeof)
@@ -41,6 +41,13 @@ setup.env$prev.data <- lapply(setup.env$prev.data, function(x)
     gsub(in.repo, out.repo, x, fixed = TRUE))
 setup.env$prev.data <- lapply(setup.env$prev.data, function(x)
     gsub(in.base, out.base, x, fixed = TRUE))
+## Added exception for sero.data
+setup.env$sero.data <- lapply(setup.env$sero.data, function(x)
+    gsub(in.root, out.root, x, fixed = TRUE))
+setup.env$sero.data <- lapply(setup.env$sero.data, function(x)
+    gsub(in.repo, out.repo, x, fixed = TRUE))
+setup.env$sero.data <- lapply(setup.env$sero.data, function(x)
+    gsub(in.base, out.base, x, fixed = TRUE))
 
 ## Temporary line to be deleted
 if(exists("infections")) rm(infections)
